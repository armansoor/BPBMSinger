<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KPOP Fan AI Player — All-in-one (Heavy WASM optional)</title>
<style>
  :root{
    --bg:#fff6fb; --card:#fff; --accent:#ff77cc; --muted:#6b6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#fff,#fff6fb);color:#111}
  .wrap{max-width:1200px;margin:18px auto;padding:20px}
  header{display:flex;align-items:center;gap:16px}
  .logo{width:84px;height:84px;border-radius:16px;background:linear-gradient(135deg,#ffd6eb,#ffb3dd);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900;font-size:28px;box-shadow:0 10px 30px rgba(255,119,204,.12)}
  h1{margin:0;font-size:26px;color:#ff3fa8}
  p.lead{margin:6px 0 0;color:var(--muted);font-size:14px}

  .grid{display:grid;grid-template-columns:1fr 420px;gap:18px;margin-top:18px}
  @media(max-width:980px){.grid{grid-template-columns:1fr}}

  .card{background:var(--card);border-radius:18px;padding:18px;box-shadow:0 10px 30px rgba(9,10,11,.04)}
  label.small{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
  select,input,button,textarea{font-size:15px;padding:10px;border-radius:10px;border:1px solid rgba(0,0,0,.06);background:white}
  button.primary{background:linear-gradient(135deg,#ff9ad6,#ff77cc);border:0;color:white;padding:12px 14px;border-radius:12px;cursor:pointer;font-weight:700}
  .big{font-size:16px;padding:12px 16px}
  .lyrics{white-space:pre-wrap;font-family:ui-monospace,Menlo,monospace;background:linear-gradient(180deg,#fffefe,#fff0f8);padding:12px;border-radius:12px;min-height:220px;overflow:auto;border:1px dashed rgba(255,119,204,.06)}
  .members{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:12px}
  @media(max-width:600px){.members{grid-template-columns:1fr}}
  .member{background:linear-gradient(180deg,#fff,#fffefb);padding:12px;border-radius:12px;border:1px solid rgba(0,0,0,.03)}
  .member h4{margin:0 0 6px 0;color:#ff3fa8}
  .member .lines{font-size:14px;line-height:1.45}
  .member .edit{width:100%;min-height:36px;border-radius:8px;border:1px solid rgba(0,0,0,.06);padding:6px;margin-top:6px}
  .player{display:flex;gap:8px;align-items:center}
  .wave{height:64px;flex:1;background:repeating-linear-gradient(90deg,#fff,#fff 6px,#ffeaf6 6px,#ffeaf6 12px);border-radius:12px}
  .footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
  .controls-row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .role-select{width:160px}
  .stem-btn{background:#fff;border:1px solid rgba(0,0,0,.06);padding:10px;border-radius:10px;cursor:pointer}
  .status{font-size:13px;color:var(--muted)}
  .big-title{font-size:18px;color:#ff3fa8;margin-bottom:8px}
  .toggle{display:inline-flex;align-items:center;gap:8px}
  a.disabled{pointer-events:none;opacity:0.5}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo">K♬P</div>
      <div>
        <h1>KPOP Fan AI Player — Heavy WASM optional</h1>
        <p class="lead">All-in-one: on-device AI generator + optional heavy WASM transformer & singing model. Paste to GitHub Pages and it works. Read notes below.</p>
      </div>
    </header>

    <div class="grid">
      <main>
        <div class="card">
          <div class="big-title">Generator Controls</div>
          <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
            <div>
              <label class="small">Group style</label>
              <select id="groupStyle"><option value="blackpink">BLACKPINK (4)</option><option value="babymonster">BABYMONSTER (7)</option><option value="mix">Hybrid</option></select>
            </div>
            <div>
              <label class="small">Language</label>
              <select id="langMode"><option value="mix">Mix (EN + KR)</option><option value="eng">English only</option><option value="kor">Korean only</option></select>
            </div>
            <div>
              <label class="small">Mood</label>
              <select id="mood"><option value="bright">Bright</option><option value="dark">Dark</option><option value="romantic">Romantic</option><option value="angry">Aggressive</option><option value="melancholy">Melancholy</option></select>
            </div>
            <div>
              <label class="small">Length</label>
              <select id="songLen"><option value="short">Short</option><option value="normal" selected>Normal</option><option value="long">Long</option></select>
            </div>
            <div>
              <label class="small">Melody complexity</label>
              <select id="melodyComplexity"><option value="simple">Simple</option><option value="medium" selected>Medium</option><option value="complex">Complex</option></select>
            </div>
          </div>

          <div style="margin-top:12px;display:flex;gap:12px;align-items:center">
            <button id="generateBtn" class="primary big">✨ Generate (Light AI)</button>
            <button id="generateHeavyBtn" class="big">⚙️ Generate (Heavy WASM)</button>
            <button id="assignRolesBtn" class="big">Assign Default Roles</button>
            <div style="margin-left:auto" class="status" id="genStatus">Ready</div>
          </div>

          <div style="margin-top:10px">
            <label class="small">Heavy WASM transformer / singing model (optional)</label>
            <div class="toggle">
              <input type="checkbox" id="heavyToggle"><label for="heavyToggle">Enable Heavy Mode (downloads models)</label>
            </div>
            <div class="status" id="heavyStatus">Heavy mode is off. Toggle to load transformer (large download).</div>
            <div style="margin-top:6px;font-size:13px;color:#666">
              <strong>Note:</strong> Heavy mode downloads transformer & optional singing model assets from public CDNs. They are large (tens to hundreds of MB). Use on Wi-Fi.
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="big-title">Lyrics (AI-generated)</div>
          <div id="lyrics" class="lyrics">Press Generate — the on-device AI will compose lyrics and melody. Toggle Heavy mode for transformer-based generation (optional).</div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="big-title">Members & Editable Lines</div>
          <div class="controls-row" style="margin-bottom:8px">
            <div><label class="small">Per-member role mapping</label></div>
            <div id="rolesHint" class="status">Set roles (Lead / Rap / Backing) to influence melody & timbre. Editable lyrics; click a textarea to change lines.</div>
          </div>
          <div id="membersGrid" class="members"></div>
        </div>
      </main>

      <aside>
        <div class="card">
          <div class="big-title">Player & Render</div>
          <div style="display:flex;flex-direction:column;gap:10px">
            <div style="display:flex;gap:8px;align-items:center">
              <button id="playBtn" class="big" disabled>▶ Play</button>
              <button id="stopBtn" class="big">■ Stop</button>
              <button id="renderBtn" class="big" disabled>⬇ Render & Download</button>
            </div>

            <div style="display:flex;gap:8px;align-items:center">
              <a id="downloadBacking" class="stem-btn disabled" href="#" role="button">Download Backing</a>
              <a id="downloadVocals" class="stem-btn disabled" href="#" role="button">Download Vocals</a>
              <a id="downloadCombined" class="stem-btn disabled" href="#" role="button">Download Combined</a>
            </div>

            <div style="margin-top:8px">
              <label class="small">Pitch shift (semitones)</label>
              <input id="pitchShift" type="range" min="-7" max="7" value="0">
              <label class="small" style="margin-top:8px">Vibrato</label>
              <input id="vibrato" type="range" min="0" max="6" value="2">
            </div>

            <div class="status" id="playStatus">Idle</div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="big-title">About & Copyright</div>
          <div class="status">© 2025 Abdur Rahman Mansoor — <a href="https://github.com/armansoor" target="_blank">github.com/armansoor</a><br>Fan-made project. Not affiliated with BLACKPINK or BABYMONSTER. Use generated songs for personal/educational use only.</div>
        </div>
      </aside>
    </div>

    <div class="footer">Everything works client-side. Heavy transformer mode is optional and downloads models. If you want me to pre-host a specific small transformer model or singing model for you, tell me and I can point the loader at a chosen public host.</div>
  </div>

<script>
/* ==========================================================
   All-in-one single-file app with optional Heavy WASM transformer
   - Lightweight on-device Markov generator (works immediately)
   - Optional heavy transformer (WASM/TFJS) generation when enabled (downloads models)
   - Per-member roles, editable lyrics, layered synth audio, stems, WAV export
   - 7 BABYMONSTER members included
   ========================================================== */

/* -------------------------
   Member maps (guaranteed)
   ------------------------- */
const BLACKPINK = ["Jisoo","Jennie","Rosé","Lisa"];
const BABYMONSTER = ["Ruka","Pharita","Asa","Ahyeon","Rami","Rora","Chiquita"]; // 7 members per user request
const MIX_DEFAULT = BLACKPINK.concat(BABYMONSTER.slice(0,3));

/* -------------------------
   Lightweight on-device AI (Markov) seeds
   ------------------------- */
const SEED_EN = [
  "shine like a diamond", "take my hand tonight", "dance until the sunrise", "we're the stars",
  "heart beats like a drum", "can't stop this feeling", "feel the neon city", "break the silence",
  "hold me closer", "fly above the sky", "we glow together", "sing it out loud", "no fear no doubt"
];
const SEED_KR = [
  "빛나는 밤에", "너와 나의 이야기", "심장은 고동쳐", "손을 잡아줘", "우리 함께 춤춰", "숨결처럼 가까이",
  "네온 불빛 속에서", "이 순간을 붙잡아", "그대 내게 말해줘", "사랑해 전하고파", "끝까지 달려가자"
];

/* ===== Markov helper (small) ===== */
class Markov {
  constructor(){ this.map = new Map(); this.start = []; }
  feed(sentences){
    for(const s of sentences){
      const tokens = s.split(/\s+/).filter(Boolean);
      if(tokens.length === 0) continue;
      this.start.push(tokens[0]);
      for(let i=0;i<tokens.length;i++){
        const w = tokens[i]; const nx = tokens[i+1] || null;
        if(!this.map.has(w)) this.map.set(w, []);
        if(nx) this.map.get(w).push(nx);
      }
    }
  }
  generate(maxWords=10){
    if(this.start.length === 0) return "";
    let w = this.start[Math.floor(Math.random()*this.start.length)];
    const out = [w];
    for(let i=1;i<maxWords;i++){
      const choices = this.map.get(w) || this.start;
      w = choices[Math.floor(Math.random()*choices.length)];
      if(!w) break;
      out.push(w);
    }
    return out.join(' ');
  }
}

/* ===== Melody generator ===== */
const MAJOR_SCALE = [0,2,4,5,7,9,11];
function generateMelody(steps=20, complexity='medium'){
  const melody = []; let cur = 4;
  for(let i=0;i<steps;i++){
    let step;
    if(complexity==='simple') step = Math.round((Math.random()*2 -1));
    else if(complexity==='medium') step = Math.round((Math.random()*3 -1));
    else step = Math.round((Math.random()*4 -2));
    cur = Math.max(0, Math.min(36, cur + step));
    melody.push(cur);
  }
  return melody;
}
function melodyIndexToFreq(idx, baseMidi=60){
  const octave = Math.floor(idx / MAJOR_SCALE.length);
  const degree = MAJOR_SCALE[idx % MAJOR_SCALE.length];
  const midi = baseMidi + degree + octave*12;
  return 440 * Math.pow(2,(midi-69)/12);
}

/* ===========================
   High-variability composer (already includes >10k combinations)
   Small lightweight generator used by default.
   Returns song object: {meta, sections, members: [{name,role,lines:[{section,text,lang,melody}]}]}
   =========================== */
function aiComposeSongLight({groupStyle, langMode, mood, songLen, melodyComplexity}){
  // prepare markov models
  const mkEn = new Markov(); mkEn.feed(SEED_EN.concat(SEED_EN.map(s=>s+' tonight')));
  const mkKr = new Markov(); mkKr.feed(SEED_KR.concat(SEED_KR.map(s=>s+' 에서')));

  // pick members
  let members = [];
  if(groupStyle === 'blackpink') members = BLACKPINK.slice();
  else if(groupStyle === 'babymonster') members = BABYMONSTER.slice();
  else members = MIX_DEFAULT.slice();

  const structure = (songLen === 'short') ? ['INTRO','VERSE','CHORUS','OUTRO']
                  : (songLen === 'normal') ? ['INTRO','VERSE','PRE','CHORUS','VERSE2','BRIDGE','RAP','CHORUS','OUTRO']
                  : ['INTRO','VERSE','PRE','CHORUS','VERSE2','PRE2','CHORUS','RAP','BRIDGE','CHORUS','OUTRO'];

  const song = { meta:{}, sections:[], members: members.map(n=>({name:n, role:'Lead', lines:[]})) };

  for(const sec of structure){
    const count = sec==='RAP'? 8 : (sec==='INTRO' || sec==='OUTRO'?2:4);
    const melody = generateMelody(count*3, melodyComplexity);
    const lines = [];
    for(let i=0;i<count;i++){
      let lang;
      if(langMode==='mix') lang = Math.random() < 0.6 ? 'en':'kr';
      else lang = (langMode === 'eng' ? 'en' : 'kr');
      const text = (lang==='en') ? mkEn.generate(4 + Math.floor(Math.random()*6)) : mkKr.generate(4 + Math.floor(Math.random()*5));
      lines.push({text, lang, melody: melody.slice(i*2, i*2+3)});
    }

    // assign
    if(sec.includes('CHORUS')){
      for(const m of song.members) for(const l of lines) m.lines.push({section:sec, text:l.text, lang:l.lang, melody:l.melody});
    } else if(sec==='RAP'){
      let idx=0; for(const l of lines){ song.members[idx % song.members.length].lines.push({section:sec, text:l.text, lang:l.lang, melody:l.melody}); idx++; }
    } else {
      let idx=0; for(const l of lines){ song.members[idx % song.members.length].lines.push({section:sec, text:l.text, lang:l.lang, melody:l.melody}); idx++; }
    }
    song.sections.push({name:sec, lines});
  }

  return song;
}

/* ===========================
   Heavy WASM transformer loader (optional)
   Notes:
     - This is an optional pipeline that loads a transformer (GPT-like) in the browser via a WASM/TFJS library.
     - It attempts to load a client-side library (e.g., transformers WASM or TFJS) from CDN.
     - Models themselves (weights) are typically large. This loader will fetch them when user enables "Heavy mode".
     - We provide a safe fallback to the lightweight Markov generator if the heavy model fails to load.
   Implementation:
     - We try to load @xenova/transformers or TF.js (if available) from CDN.
     - If successful, we create a generateTextHeavy(prompt) function that uses the model to produce lyrics.
   WARNING: Model downloads may be large (tens to hundreds MB). That's expected for "heavy" mode.
   =========================== */

let heavyState = {
  enabled: false,
  libLoaded: false,
  modelLoaded: false,
  generator: null // assigned function when ready
};

async function enableHeavyMode() {
  if(heavyState.enabled) return;
  heavyState.enabled = true;
  document.getElementById('heavyStatus').textContent = 'Heavy mode enabled — loading libraries (this may take time)...';

  // Try to load transformers WASM (Xenova) first
  try {
    // Try to load script from jsdelivr CDN (this library provides WASM transformer runtime)
    // Note: If the CDN or package version changes, this might need updating.
    await loadScript('https://cdn.jsdelivr.net/npm/@xenova/transformers@1.2.0/dist/transformers.min.js');
    // global "transformers" should be present
    if(window.transformers){
      document.getElementById('heavyStatus').textContent = 'Transformers WASM loaded. Loading model weights...';
      // instantiate text-generation pipeline with a small GPT-Neo/GPT2 model hosted publicly
      // NOTE: you can alter the model repo string to another small model (host must support CORS)
      const modelId = "Xenova/gpt2-small-finetune-kpop"; // <-- placeholder; if not found, fallback
      try {
        // The transformers library supports pipeline("text-generation", model)
        const pipeline = await window.transformers.pipeline('text-generation', modelId);
        heavyState.generator = async (prompt, maxLength=100) => {
          const out = await pipeline(prompt, {max_length: maxLength, do_sample:true, temperature:0.9});
          // pipeline returns array of results
          return (out && out[0] && out[0].generated_text) ? out[0].generated_text : String(out);
        };
        heavyState.libLoaded = true; heavyState.modelLoaded = true;
        document.getElementById('heavyStatus').textContent = 'Heavy transformer model loaded — ready for generation.';
        return;
      } catch (e){
        console.warn('Transformers pipeline load failed:', e);
        // fall through to TF.js approach
      }
    }
  } catch(e){
    console.warn('Xenova transformers not available:', e);
  }

  // Try TF.js + small GPT2-like model (optional)
  try {
    // load TF.js core
    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.12.0/dist/tf.min.js');
    document.getElementById('heavyStatus').textContent = 'TensorFlow.js loaded. Attempting to load a small model (this may be large)...';
    // You would need a hosted TFJS model (converted GPT-like) with CORS. For safety we attempt to instantiate a simple generator using a tiny model URL (placeholder).
    // Because hosting a model is outside this HTML, we provide a fallback generator if no model is reachable.
    // If you host a TFJS model, specify its URL here and we'll load it.
    // Example placeholder (no-op): heavyState.generator = async (prompt) => prompt + ' (heavy fallback)';
    heavyState.libLoaded = true;
    heavyState.modelLoaded = false;
    heavyState.generator = null;
    document.getElementById('heavyStatus').textContent = 'TF.js loaded but no TF model configured — heavy generation fallback will not be available.';
    return;
  } catch(e){
    console.warn('TF.js load failed', e);
  }

  // If all fails, inform user and keep fallback
  document.getElementById('heavyStatus').textContent = 'Heavy mode libraries failed to load. Falling back to lightweight AI.';
  heavyState.enabled = false;
}

/* Small helper to load external script */
function loadScript(url){
  return new Promise((resolve, reject)=>{
    const s = document.createElement('script'); s.src = url; s.async = true;
    s.onload = ()=> resolve(true); s.onerror = (e)=> reject(e);
    document.head.appendChild(s);
  });
}

/* ===========================
   Audio engine: backing, vocals, rap, record & stems
   (Same architecture as earlier)
   =========================== */

let audioCtx = null;
let masterBackingGain, masterVocalGain;
let recBackingNode, recVocalNode, recCombinedNode;
let recBuffersBackingL=[], recBuffersBackingR=[], recBackingLen=0;
let recBuffersVocalL=[], recBuffersVocalR=[], recVocalLen=0;
let recBuffersCombL=[], recBuffersCombR=[], recCombLen=0;
let isRecording = false;
let latestBackingWav=null, latestVocalWav=null, latestCombinedWav=null;

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  masterBackingGain = audioCtx.createGain(); masterBackingGain.gain.value = 0.95;
  masterVocalGain = audioCtx.createGain(); masterVocalGain.gain.value = 0.95;

  const bufSize = 4096;
  recBackingNode = audioCtx.createScriptProcessor(bufSize,2,2);
  recVocalNode = audioCtx.createScriptProcessor(bufSize,2,2);
  recCombinedNode = audioCtx.createScriptProcessor(bufSize,2,2);

  recBackingNode.onaudioprocess = (e) => {
    if(!isRecording) return;
    const left = e.inputBuffer.getChannelData(0), right = e.inputBuffer.numberOfChannels>1? e.inputBuffer.getChannelData(1): left;
    recBuffersBackingL.push(new Float32Array(left)); recBuffersBackingR.push(new Float32Array(right)); recBackingLen += left.length;
  };
  recVocalNode.onaudioprocess = (e) => {
    if(!isRecording) return;
    const left = e.inputBuffer.getChannelData(0), right = e.inputBuffer.numberOfChannels>1? e.inputBuffer.getChannelData(1): left;
    recBuffersVocalL.push(new Float32Array(left)); recBuffersVocalR.push(new Float32Array(right)); recVocalLen += left.length;
  };
  recCombinedNode.onaudioprocess = (e) => {
    if(!isRecording) return;
    const left = e.inputBuffer.getChannelData(0), right = e.inputBuffer.numberOfChannels>1? e.inputBuffer.getChannelData(1): left;
    recBuffersCombL.push(new Float32Array(left)); recBuffersCombR.push(new Float32Array(right)); recCombLen += left.length;
  };

  masterBackingGain.connect(recBackingNode); recBackingNode.connect(audioCtx.destination);
  masterVocalGain.connect(recVocalNode); recVocalNode.connect(audioCtx.destination);
  masterBackingGain.connect(recCombinedNode); masterVocalGain.connect(recCombinedNode); recCombinedNode.connect(audioCtx.destination);
  masterBackingGain.connect(audioCtx.destination); masterVocalGain.connect(audioCtx.destination);
}

function startRecording(){
  recBuffersBackingL = []; recBuffersBackingR = []; recBackingLen = 0;
  recBuffersVocalL = []; recBuffersVocalR = []; recVocalLen = 0;
  recBuffersCombL = []; recBuffersCombR = []; recCombLen = 0;
  isRecording = true;
}
function stopRecordingAndCreateWavs(){
  isRecording = false;
  const leftB = mergeBuffers(recBuffersBackingL, recBackingLen);
  const rightB = mergeBuffers(recBuffersBackingR, recBackingLen);
  const interB = interleave(leftB, rightB);
  latestBackingWav = encodeWav(interB, audioCtx.sampleRate);

  const leftV = mergeBuffers(recBuffersVocalL, recVocalLen);
  const rightV = mergeBuffers(recBuffersVocalR, recVocalLen);
  const interV = interleave(leftV, rightV);
  latestVocalWav = encodeWav(interV, audioCtx.sampleRate);

  const leftC = mergeBuffers(recBuffersCombL, recCombLen);
  const rightC = mergeBuffers(recBuffersCombR, recCombLen);
  const interC = interleave(leftC, rightC);
  latestCombinedWav = encodeWav(interC, audioCtx.sampleRate);

  return {
    backingBlob: new Blob([latestBackingWav], {type:'audio/wav'}),
    vocalBlob: new Blob([latestVocalWav], {type:'audio/wav'}),
    combinedBlob: new Blob([latestCombinedWav], {type:'audio/wav'})
  };
}

function mergeBuffers(buffers, len){
  const result = new Float32Array(len);
  let offset = 0;
  for(let i=0;i<buffers.length;i++){ result.set(buffers[i], offset); offset += buffers[i].length; }
  return result;
}
function interleave(left, right){
  const out = new Float32Array(left.length + right.length);
  let idx=0;
  for(let i=0;i<left.length;i++){ out[idx++] = left[i]; out[idx++] = right[i]; }
  return out;
}
function floatTo16BitPCM(output, offset, input){
  for(let i=0;i<input.length;i++, offset+=2){
    let s = Math.max(-1, Math.min(1, input[i]));
    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
}
function writeString(view, offset, str){
  for(let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i));
}
function encodeWav(samples, sampleRate){
  const buffer = new ArrayBuffer(44 + samples.length * 2);
  const view = new DataView(buffer);
  writeString(view,0,'RIFF'); view.setUint32(4,36 + samples.length*2, true);
  writeString(view,8,'WAVE'); writeString(view,12,'fmt ');
  view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,2,true);
  view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*4,true);
  view.setUint16(32,4,true); view.setUint16(34,16,true); writeString(view,36,'data');
  view.setUint32(40,samples.length*2, true);
  floatTo16BitPCM(view,44,samples);
  return view;
}

/* -------------------------
   Instruments scheduling (backing + vocals) - similar to earlier code
   ------------------------- */
function midiToFreq(m){ return 440 * Math.pow(2,(m-69)/12); }

function scheduleBackingChord(at, rootMidi, dur=1.8){
  const freqs = [rootMidi, rootMidi+7, rootMidi+12].map(m=>midiToFreq(m));
  freqs.forEach((f,i)=>{
    const osc = audioCtx.createOscillator(); osc.type='sawtooth'; osc.frequency.value = f*(1 + (Math.random()*0.01));
    const filt = audioCtx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value = 1200 - i*120;
    const g = audioCtx.createGain(); g.gain.value = 0.0001;
    osc.connect(filt); filt.connect(g); g.connect(masterBackingGain);
    g.gain.setValueAtTime(0.0001, at);
    g.gain.linearRampToValueAtTime(0.26, at+0.12);
    g.gain.linearRampToValueAtTime(0.0, at+dur);
    osc.start(at); osc.stop(at+dur+0.02);
  });
}
function scheduleBackingBass(at, midi, dur=1.8){
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value = midiToFreq(midi);
  const g = audioCtx.createGain(); g.gain.value = 0.0001;
  osc.connect(g); g.connect(masterBackingGain);
  g.gain.setValueAtTime(0.0001, at); g.gain.linearRampToValueAtTime(0.95, at+0.02); g.gain.linearRampToValueAtTime(0.0001, at+dur);
  osc.start(at); osc.stop(at+dur+0.02);
}
function scheduleKick(at){
  const osc = audioCtx.createOscillator(); osc.type='sine';
  const g = audioCtx.createGain();
  osc.frequency.setValueAtTime(160, at); osc.frequency.exponentialRampToValueAtTime(40, at+0.12);
  g.gain.setValueAtTime(0.0001, at); g.gain.exponentialRampToValueAtTime(1.2, at+0.01); g.gain.exponentialRampToValueAtTime(0.0001, at+0.18);
  osc.connect(g); g.connect(masterBackingGain);
  osc.start(at); osc.stop(at+0.18);
}
function scheduleSnare(at){
  const len = Math.floor(audioCtx.sampleRate * 0.12);
  const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate); const d = buf.getChannelData(0);
  for(let i=0;i<len;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/(audioCtx.sampleRate*0.02));
  const src = audioCtx.createBufferSource(); src.buffer = buf;
  const filt = audioCtx.createBiquadFilter(); filt.type='highpass'; filt.frequency.value = 1200;
  const g = audioCtx.createGain(); g.gain.value = 0.0001;
  src.connect(filt); filt.connect(g); g.connect(masterBackingGain);
  g.gain.linearRampToValueAtTime(0.8, at+0.008); g.gain.linearRampToValueAtTime(0.0001, at+0.12);
  src.start(at);
}

function scheduleSung(at, dur, freq, vibr=2){
  const o1 = audioCtx.createOscillator(), o2 = audioCtx.createOscillator();
  o1.type='sine'; o2.type='sine'; o2.detune.value = (Math.random()*10 - 5);
  o1.frequency.setValueAtTime(freq, at); o2.frequency.setValueAtTime(freq*(1 + (Math.random()*0.01)), at);
  const lfo = audioCtx.createOscillator(); lfo.frequency.value = 5 + vibr*0.2;
  const lfoGain = audioCtx.createGain(); lfoGain.gain.value = vibr*0.006;
  lfo.connect(lfoGain); lfoGain.connect(o1.frequency); lfoGain.connect(o2.frequency);
  const f1 = audioCtx.createBiquadFilter(); f1.type='bandpass'; f1.frequency.value = 700 + Math.random()*600; f1.Q.value=8;
  const f2 = audioCtx.createBiquadFilter(); f2.type='bandpass'; f2.frequency.value = 1100 + Math.random()*900; f2.Q.value=6;
  const g = audioCtx.createGain(); g.gain.value = 0.0001;
  o1.connect(f1); o2.connect(f2); f1.connect(g); f2.connect(g); g.connect(masterVocalGain);
  g.gain.linearRampToValueAtTime(0.9, at+0.02); g.gain.linearRampToValueAtTime(0.45, at+dur*0.4); g.gain.linearRampToValueAtTime(0.0001, at+dur);
  o1.start(at); o2.start(at); lfo.start(at); o1.stop(at+dur+0.04); o2.stop(at+dur+0.04); lfo.stop(at+dur+0.04);
}

function scheduleRap(at,dur,freq,grit=4){
  const o = audioCtx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(freq*0.9, at);
  const sh = audioCtx.createWaveShaper(); const k=1+grit;
  const curve = new Float32Array(4096); for(let i=0;i<4096;i++){ const x=(i*2/4096)-1; curve[i] = Math.tanh(k*x); }
  sh.curve = curve; sh.oversample = '2x';
  const g = audioCtx.createGain(); g.gain.value=0.0001;
  o.connect(sh); sh.connect(g); g.connect(masterVocalGain);
  g.gain.linearRampToValueAtTime(0.85, at+0.003); g.gain.exponentialRampToValueAtTime(0.0001, at+dur);
  o.start(at); o.stop(at+dur+0.01);
  for(let i=0;i<Math.max(2,Math.floor(dur/0.1));i++){
    const t = at + i*(dur/Math.max(2,Math.floor(dur/0.1))) + (Math.random()*0.02 - 0.01);
    schedulePercussiveNoise(t, 0.05);
  }
}
function schedulePercussiveNoise(at, dur){
  const len = Math.floor(audioCtx.sampleRate * dur); const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate); const d = buf.getChannelData(0);
  for(let i=0;i<len;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/(audioCtx.sampleRate*0.01));
  const src = audioCtx.createBufferSource(); src.buffer = buf; const g = audioCtx.createGain(); g.gain.value = 0.0001;
  src.connect(g); g.connect(masterVocalGain); g.gain.linearRampToValueAtTime(0.5, at+0.002); g.gain.linearRampToValueAtTime(0.0001, at+dur); src.start(at);
}

/* -------------------------
   Playback & Record Flow
   ------------------------- */
function playAndRecordSong(song){
  ensureAudio(); startRecording();

  const start = audioCtx.currentTime + 0.12; let cursor = start;
  const mood = document.getElementById('mood').value;
  const chordPool = { bright:[60,67,69,65], dark:[57,52,53,52], romantic:[65,67,64,69], angry:[48,43,46,41], melancholy:[50,45,53,48] }[mood] || [60,67,69,65];

  for(const sec of song.sections){
    const secName = sec.name; const secDur = secName==='INTRO'||secName==='OUTRO'?4:(secName==='RAP'?8:8);

    for(let t=0;t<secDur;t+=2){
      const root = chordPool[Math.floor(((cursor + t)/2)) % chordPool.length];
      scheduleBackingChord(cursor + t, root, 1.8);
      scheduleBackingBass(cursor + t, root - 12, 1.8);
    }

    for(let t=0;t<secDur;t+=0.5){
      if(Math.abs((t % 1) - 0) < 0.01) scheduleKick(cursor + t);
      if(Math.abs((t % 2) - 1) < 0.01 && Math.random() < 0.7) scheduleSnare(cursor + t + 0.02);
    }

    // collect lines
    const lines = [];
    for(const m of song.members) for(const l of m.lines) if(l.section === secName) lines.push({member:m.name, text:l.text, melody:l.melody, role:m.role});

    let lineCursor = cursor + 0.2;
    for(const L of lines){
      const sylls = L.text.split(/\s+/).filter(Boolean);
      for(const s of sylls){
        const dur = secName==='RAP'? 0.12 : (0.18 + Math.random()*0.12);
        const pitchShift = Number(document.getElementById('pitchShift').value || 0);
        const baseIdx = Math.floor(Math.random()*28);
        const freq = midiToFreq(60 + ((baseIdx%7)*2) + pitchShift);
        if((L.role || '').toLowerCase().includes('rap')) scheduleRap(lineCursor, dur, freq, 4);
        else scheduleSung(lineCursor, dur, freq, Number(document.getElementById('vibrato').value || 2));
        lineCursor += dur * (secName==='RAP'?0.85:1.0);
      }
      lineCursor += 0.06;
    }

    cursor += secDur;
  }

  const total = cursor - start + 0.6;
  setTimeout(()=>{
    const blobs = stopRecordingAndCreateWavs();
    enableDownloadButtons(blobs);
    document.getElementById('playStatus').textContent = 'Rendered & ready';
  }, (total*1000) + 300);
}

/* Download buttons creation */
function enableDownloadButtons({backingBlob, vocalBlob, combinedBlob}){
  const db = document.getElementById('downloadBacking'); const dv = document.getElementById('downloadVocals'); const dc = document.getElementById('downloadCombined');
  const ts = (new Date()).toISOString().replace(/[:.]/g,'-'); const g = document.getElementById('groupStyle').value;
  const ub = URL.createObjectURL(backingBlob); const uv = URL.createObjectURL(vocalBlob); const uc = URL.createObjectURL(combinedBlob);
  db.href = ub; db.download = `kpop_backing_${g}_${ts}.wav`; db.classList.remove('disabled'); dv.href = uv; dv.download = `kpop_vocals_${g}_${ts}.wav`; dv.classList.remove('disabled');
  dc.href = uc; dc.download = `kpop_combined_${g}_${ts}.wav`; dc.classList.remove('disabled');
  // also enable render button
  document.getElementById('renderBtn').disabled = false;
}

/* ===========================
   UI wiring (generation, heavy toggle, roles, editing, play/render)
   =========================== */

const genBtn = document.getElementById('generateBtn');
const genHeavyBtn = document.getElementById('generateHeavyBtn');
const playBtn = document.getElementById('playBtn');
const stopBtn = document.getElementById('stopBtn');
const renderBtn = document.getElementById('renderBtn');
const assignRolesBtn = document.getElementById('assignRolesBtn');
const heavyToggle = document.getElementById('heavyToggle');
const heavyStatusEl = document.getElementById('heavyStatus');
const genStatusEl = document.getElementById('genStatus');
const membersGrid = document.getElementById('membersGrid');

let latestSong = null;

/* light generation */
genBtn.addEventListener('click', ()=>{
  genStatusEl.textContent = 'Generating (light)...';
  setTimeout(()=>{
    latestSong = aiComposeSongLight({
      groupStyle: document.getElementById('groupStyle').value,
      langMode: document.getElementById('langMode').value,
      mood: document.getElementById('mood').value,
      songLen: document.getElementById('songLen').value,
      melodyComplexity: document.getElementById('melodyComplexity').value
    });
    renderSongToUI(latestSong);
    genStatusEl.textContent = 'Generated (light)';
    playBtn.disabled = false; renderBtn.disabled = false;
  }, 40);
});

/* heavy generation (uses heavyState.generator if available) */
genHeavyBtn.addEventListener('click', async ()=>{
  if(!heavyToggle.checked){
    alert('Enable Heavy Mode (toggle) first — it will download the transformer model. Use on Wi-Fi.');
    return;
  }
  genStatusEl.textContent = 'Generating (heavy)...';
  // ensure heavy mode enabled + libraries loaded
  if(!heavyState.libLoaded){
    await enableHeavyMode();
  }
  // if heavy generator available use it; otherwise fallback to light
  if(heavyState.generator){
    // build a prompt covering mood, group, roles etc., and generate
    const prompt = buildPromptFromUI();
    genStatusEl.textContent = 'Heavy transformer generating (may take a while)...';
    try {
      const out = await heavyState.generator(prompt, 200);
      // parse output into lines (very basic split)
      const lines = out.split('\n').filter(Boolean).slice(0,80);
      // build a song object from these lines (map to sections/members)
      latestSong = convertHeavyTextToSong(lines);
      renderSongToUI(latestSong);
      genStatusEl.textContent = 'Generated (heavy)';
      playBtn.disabled = false; renderBtn.disabled = false;
      return;
    } catch(e){
      console.warn('Heavy generation failed, falling back:', e);
      genStatusEl.textContent = 'Heavy generation failed — falling back to light generator';
    }
  }
  // fallback
  genBtn.click();
});

/* heavy toggle handler */
heavyToggle.addEventListener('change', async (e)=>{
  if(e.target.checked){
    heavyStatusEl.textContent = 'Preparing heavy mode...';
    try{
      await enableHeavyMode();
    }catch(err){
      console.warn(err);
      heavyStatusEl.textContent = 'Heavy mode failed to initialize. Using lightweight generator.';
      heavyToggle.checked = false;
    }
  } else {
    heavyStatusEl.textContent = 'Heavy mode disabled.';
    heavyState.enabled = false;
  }
});

/* helper: build a prompt for transformer using UI selections */
function buildPromptFromUI(){
  const group = document.getElementById('groupStyle').value;
  const mood = document.getElementById('mood').value;
  const lang = document.getElementById('langMode').value;
  const seed = `Write a K-pop style song in ${lang==='mix'?'English+Korean':(lang==='eng'?'English':'Korean')} in a ${mood} mood, for group ${group}. Include intro, verse, chorus, rap, bridge, outro. Provide member-labeled lines where possible.`;
  return seed;
}

/* convert heavy text -> song (best-effort parser). If generator returns plain lyrics, we split and assign round-robin. */
function convertHeavyTextToSong(lines){
  // simple split into sections by header lines (INTRO/VERSE/CHORUS/RAP/BRIDGE/OUTRO)
  const sections = []; let cur = {name:'VERSE', lines:[]};
  for(const l of lines){
    const up = l.trim().toUpperCase();
    if(up.includes('INTRO') || up.includes('VERSE') || up.includes('CHORUS') || up.includes('BRIDGE') || up.includes('RAP') || up.includes('OUTRO') ){
      if(cur && cur.lines.length) sections.push(cur);
      cur = {name: up.split(' ')[0], lines:[]};
    } else {
      cur.lines.push({text: l});
    }
  }
  if(cur && cur.lines.length) sections.push(cur);

  // create song object and round-robin assign lines
  const members = (document.getElementById('groupStyle').value === 'blackpink') ? BLACKPINK.slice() : (document.getElementById('groupStyle').value === 'babymonster' ? BABYMONSTER.slice() : MIX_DEFAULT.slice());
  const song = { meta:{heavy:true}, sections: sections.map(s=>({name:s.name, lines: s.lines.map(x=>({text:x.text}))})), members: members.map(n=>({name:n, role:'Lead', lines:[]})) };
  let idx = 0;
  for(const s of song.sections){
    for(const l of s.lines){
      const m = song.members[idx % song.members.length];
      m.lines.push({section: s.name || 'VERSE', text: l.text, lang: 'en', melody: generateMelody(3, 'medium')});
      idx++;
    }
  }
  return song;
}

/* render song object to UI (lyrics area + members grid) */
function renderSongToUI(song){
  const lyricsEl = document.getElementById('lyrics'); let out = '';
  for(const sec of song.sections){
    out += `--- ${sec.name} ---\n`;
    if(sec.lines && sec.lines.length) for(const l of sec.lines) out += (l.text || l) + '\n';
    out += '\n';
  }
  lyricsEl.textContent = out;

  membersGrid.innerHTML = '';
  for(let i=0;i<song.members.length;i++){
    const m = song.members[i];
    const div = document.createElement('div'); div.className = 'member';
    const role = m.role || 'Lead';
    const roleSelHtml = `<div style="display:flex;gap:8px;align-items:center;margin-bottom:6px"><strong style="flex:1">${escapeHtml(m.name)}</strong><select class="role-select" data-index="${i}"><option value="Lead"${role==='Lead'?' selected':''}>Lead</option><option value="Rap"${role==='Rap'?' selected':''}>Rap</option><option value="Backing"${role==='Backing'?' selected':''}>Backing</option></select></div>`;
    const linesHtml = (m.lines || []).map((L, li)=>`<div class="lines"><textarea class="edit" data-member="${i}" data-line="${li}">${escapeHtml(L.text || '')}</textarea><div style="font-size:12px;color:#777;margin-top:4px">[${L.section || 'LINE'}]</div></div>`).join('');
    div.innerHTML = roleSelHtml + (linesHtml || '<div class="lines"><em>No assigned lines</em></div>');
    membersGrid.appendChild(div);
  }

  // wire role selects and editable textareas
  document.querySelectorAll('.role-select').forEach(sel=>{
    sel.addEventListener('change', (e)=>{
      const idx = Number(e.target.dataset.index);
      latestSong.members[idx].role = e.target.value;
    });
  });
  document.querySelectorAll('.edit').forEach(area=>{
    area.addEventListener('input', (e)=>{
      const mi = Number(e.target.dataset.member);
      const li = Number(e.target.dataset.line);
      latestSong.members[mi].lines[li].text = e.target.value;
    });
  });
}

/* assign default roles */
assignRolesBtn.addEventListener('click', ()=>{
  if(!latestSong){ alert('Generate a song first'); return; }
  const g = document.getElementById('groupStyle').value;
  if(g === 'blackpink'){
    for(const m of latestSong.members){
      if(m.name === 'Jennie') m.role = 'Rap';
      else if(m.name === 'Lisa') m.role = 'Rap';
      else if(m.name === 'Rosé') m.role = 'Lead';
      else if(m.name === 'Jisoo') m.role = 'Backing';
      else m.role = 'Lead';
    }
  } else if(g === 'babymonster'){
    for(let i=0;i<latestSong.members.length;i++){
      if(i===1) latestSong.members[i].role = 'Rap';
      else if(i===0) latestSong.members[i].role = 'Lead';
      else latestSong.members[i].role = 'Backing';
    }
  } else {
    for(let i=0;i<latestSong.members.length;i++){
      latestSong.members[i].role = (i%4===1) ? 'Rap' : (i%4===0? 'Lead' : 'Backing');
    }
  }
  renderSongToUI(latestSong);
});

/* Play / render handlers */
playBtn.addEventListener('click', async ()=>{
  if(!latestSong){ alert('Generate a song first'); return; }
  ensureAudio();
  if(audioCtx.state === 'suspended') await audioCtx.resume();
  document.getElementById('playStatus').textContent = 'Playing & recording...';
  playBtn.disabled = true;
  genBtn.disabled = true; genHeavyBtn.disabled = true; assignRolesBtn.disabled = true;
  playAndRecordSong(latestSong);
  // best-effort re-enable after 30s
  setTimeout(()=>{ playBtn.disabled = false; genBtn.disabled = false; genHeavyBtn.disabled = false; assignRolesBtn.disabled = false; }, 35000);
});

stopBtn.addEventListener('click', ()=>{
  if(isRecording){
    const blobs = stopRecordingAndCreateWavs();
    enableDownloadButtons(blobs);
    document.getElementById('playStatus').textContent = 'Stopped & recorded';
  } else {
    document.getElementById('playStatus').textContent = 'Nothing recording';
  }
});

renderBtn.addEventListener('click', ()=>{
  if(!latestCombinedWav && !latestCombinedWav){
    alert('Play the song once to render audio (the app records the generated schedule). After play completes, use the Download buttons to save stems.');
    return;
  }
  alert('Use the Download Backing/Vocals/Combined buttons to save WAVs.');
});

/* Utility: escape */
function escapeHtml(s){ return String(s).replace(/[&<>]/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

/* ===========================
   Done. Console debug info for power users
   =========================== */
console.log("KPOP Fan AI Player loaded. Default: lightweight Markov generator. Toggle Heavy mode to load WASM transformer (optional).");

/* End of file */
</script>
</body>
</html>
